(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{358:function(a,t,e){"use strict";e.r(t);var s=e(42),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("[TOC]")]),a._v(" "),e("h1",{attrs:{id:"interview"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#interview"}},[a._v("#")]),a._v(" InterView")]),a._v(" "),e("h2",{attrs:{id:"底层原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#底层原理"}},[a._v("#")]),a._v(" 底层原理")]),a._v(" "),e("h3",{attrs:{id:"oc对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oc对象"}},[a._v("#")]),a._v(" OC对象")]),a._v(" "),e("p",[a._v("一个NSObject对象占用多少内存？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）\n")])])]),e("p",[a._v("对象的isa指针指向哪里？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" instance对象的isa指向class对象 class对象的isa指向meta-class对象 meta-class对象的isa指向基类的meta-class对象\n")])])]),e("p",[a._v("OC的类信息存放在哪里？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("对象方法、属性、成员变量、协议信息，存放在class对象中 类方法，存放在meta-class对象中 成员变量的具体值，存放在instance对象\n")])])]),e("p",[a._v("class_rw_t 与 class_ro_t 区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class_rw_t结构体内有一个指向class_ro_t结构体的指针.\nclass_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集\n\n当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容\n属性(property)存放在class_rw_t中，实例变量(ivar)存放在class_ro_t中。\n")])])]),e("p",[a._v("msg_send 消息转发")]),a._v(" "),e("div",{staticClass:"language-objective-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("分为三个阶段\n1、动态方法解析 \n\n  + (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(run)) {\n        return NO;//返回 NO， 才会执行第二步\n    }\n    return [super resolveInstanceMethod:sel];\n\t}\n\t\n2、快速转发 \n  \n  - (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(run)) {\n//        return  [Dog new]; //替换其他消息接受者\n        return nil; //返回nil 则会走到第3阶段，完全消息转发机制（慢速转发）\n    }\n    return  [super forwardingTargetForSelector:aSelector];\n\t}\n  \n3、完全消息转发\n  \n  3.1方法签名\n  - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(run)) {\n        Dog *dog = [Dog new];\n        return [dog methodSignatureForSelector:aSelector];\n    }\n    return [super methodSignatureForSelector:aSelector];\n\t}\n\t3.2 消息转发\n    - (void)forwardInvocation:(NSInvocation *)anInvocation {\n    Dog *dog = [Dog new];\n    if ([dog respondsToSelector:anInvocation.selector]) {\n        [anInvocation invokeWithTarget:dog];\n    } else {\n        [super forwardInvocation:anInvocation];\n    }\n\t}\n")])])]),e("p",[e("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008eGmZEly1gn3kd0skfkj30lq0cb3z6.jpg",alt:""}})]),a._v(" "),e("p",[a._v("iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 willChangeValueForKey: 父类原来的setter didChangeValueForKey: 内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）\n")])])]),e("p",[a._v("IMP、SEL、Method的区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("SEL是方法编号，也是方法名\nIMP是函数实现指针，找IMP就是找函数实现的过程\nMethod就是具体的实现\nSEL和IMP的关系就可以解释为：\nSEL就相当于书本的⽬录标题\nIMP就是书本的⻚码\nMethod就是具体页码对应的内容\nSEL是在dyld加载镜像到内存时，通过_read_image方法加载到内存的表中了\n")])])]),e("h2",{attrs:{id:"其他原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他原理"}},[a._v("#")]),a._v(" 其他原理")]),a._v(" "),e("h4",{attrs:{id:"单例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例"}},[a._v("#")]),a._v(" 单例")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("使用@synchronized虽然解决了多线程的问题，但是并不完美。因为只有在single未创建时，我们加锁才是有必要的。如果single已经创建.这时候锁不仅没有好处，而且还会影响到程序执行的性能（多个线程执行@synchronized中的代码时，只有一个线程执行，其他线程需要等待）。\n\n当onceToken= 0时，线程执行dispatch_once的block中代码 当onceToken= -1时，线程跳过dispatch_once的block中代码不执行 当onceToken为其他值时，线程被阻塞，等待onceToken值改变\n")])])]),e("h4",{attrs:{id:"通知"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通知"}},[a._v("#")]),a._v(" 通知")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/4a44b9a15fe9?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation",target:"_blank",rel:"noopener noreferrer"}},[a._v("通知实现原理参考"),e("OutboundLink")],1)]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("两张表 Named Table NotificationName作为表的key， nameless table 没有传入NotificationName wildcard\n")])])]),e("h4",{attrs:{id:"copy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[a._v("#")]),a._v(" copy")]),a._v(" "),e("h5",{attrs:{id:"copy-与-strong"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#copy-与-strong"}},[a._v("#")]),a._v(" "),e("strong",[a._v("copy 与 strong")])]),a._v(" "),e("p",[a._v("使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.")]),a._v(" "),e("p",[a._v("如果我们使用 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.")]),a._v(" "),e("div",{staticClass:"language-objective-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('\t\tNSMutableString *string = [[NSMutableString alloc] initWithString:@"0"];\n    \n    NSString *copyString = [string mutableCopy];\n    NSString *strongString = string;\n    \n    [string appendString:@"1"];\n    \n    NSLog(@"copyString = %@", copyString);\n    NSLog(@"strongString = %@", strongString);\n')])])]),e("h5",{attrs:{id:"copy-与-mutablecopy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#copy-与-mutablecopy"}},[a._v("#")]),a._v(" copy 与 mutableCopy")]),a._v(" "),e("p",[a._v("不可变对象 copy 指针拷贝  浅拷贝 仅此一种情况")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}}),a._v(" "),e("th",{staticStyle:{"text-align":"center"}},[a._v("copy")]),a._v(" "),e("th",{staticStyle:{"text-align":"center"}},[a._v("mutableCopy")])])]),a._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("不可变对象")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("浅拷贝 （指针拷贝）")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("深拷贝")])]),a._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("可变对象")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("深拷贝")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("深拷贝")])])])]),a._v(" "),e("h3",{attrs:{id:"weak的实现原理-sidetable的内部结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weak的实现原理-sidetable的内部结构"}},[a._v("#")]),a._v(" weak的实现原理，sideTable的内部结构")]),a._v(" "),e("p",[a._v("weak表其实是一个hash表，key 是所指对象的地址，value 是 weak 指针的地址数组，")]),a._v(" "),e("p",[a._v("sideTable是一个结构体，内部主要有引用计数表和弱引用表两个成员，内存存储的其实都是对象的地址、引用计数和weak变量的地址，而不是对象本身的数据")]),a._v(" "),e("h2",{attrs:{id:"block"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#block"}},[a._v("#")]),a._v(" Block")]),a._v(" "),e("p",[a._v("block的原理是什么 本质是什么")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("本质是一个 oc 对象， 内部也有一个 isa 指针\n内部封装了 block 执行逻辑的函数\n")])])]),e("h3",{attrs:{id:"block-的本质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#block-的本质"}},[a._v("#")]),a._v(" Block 的本质")]),a._v(" "),e("p",[e("strong",[a._v("结构体对象")])]),a._v(" "),e("div",{staticClass:"language-objective-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('int age = 20;\nvoid (^block) (void) = ^ {\n\tNSLog(@"age is %d", age);\n};\n')])])]),e("p",[a._v("变量自动捕获👇")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("struct __main_block_impl_0 {\n\tstruct __block_impl impl; //impl 结构体见👇\n\tstruct __main_block_desc_0* Desc;\n\tint age;// 自动变量捕获\n}\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("struct __block_impl {\n\tvoid *isa;\n\tint Flags;\n\tint Reserved;\n\tvoid *FuncPtr; //指向 block 内部实现的函数地址 (见👇)\n}\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 封装了 block 执行逻辑的函数\nstatic void __main_block_func_0 () {\n\t//TODO\n}\n")])])]),e("h3",{attrs:{id:"变量捕获"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量捕获"}},[a._v("#")]),a._v(" 变量捕获")]),a._v(" "),e("p",[a._v("auto 值传递")]),a._v(" "),e("p",[a._v("static 指针传递")]),a._v(" "),e("p",[a._v("全局变量 不捕获 直接访问")]),a._v(" "),e("p",[a._v("局部变量需要捕获是因为需要"),e("code",[a._v("跨函数")]),a._v("访问")]),a._v(" "),e("h3",{attrs:{id:"block-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#block-类型"}},[a._v("#")]),a._v(" Block 类型")]),a._v(" "),e("p",[e("code",[a._v("继承自NSBlock类型")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("globleBlock 没有访问 auto 变量 （访问 static 和 全局变量仍让是 globelBlock）\n\n​ stackBlock 访问了 auto 变量 (MRC 下能打印出来, ARC下会自动调动 copy ---\x3e mallocBlock)\n\n​ mallocBlock ----\x3e stackBlock 调用了 copy （栈 --- > 堆上）  \n")])])]),e("h3",{attrs:{id:"block的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#block的作用"}},[a._v("#")]),a._v(" __block的作用")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("__block 可解决 block 内部无法修改 auto 变量的问题 \n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("编译器会将__block变量包装成一个对象 __Block_byref_xxx_0\n")])])]),e("p",[a._v("基本数据类型 "),e("code",[a._v("int age = 0;")]),a._v(" 编译器会将 age 包装成 "),e("code",[a._v("__Block_byref_age_0")]),a._v(" 结构体")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008eGmZEly1gng930adqfj30ec06c0tl.jpg",alt:""}})]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1.__main_block_impl_0 结构体内持有  __Block_byref_age_0\n2.__Block_byref_age_0 内部持有 __forwarding 指针指向自己\n")])])]),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://tva1.sinaimg.cn/large/008eGmZEly1gng939naeuj30mk07676r.jpg"}}),a._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://tva1.sinaimg.cn/large/008eGmZEly1gng92mq03kj30li09smyv.jpg"}}),a._v(" "),e("h3",{attrs:{id:"block-内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#block-内存管理"}},[a._v("#")]),a._v(" Block 内存管理")]),a._v(" "),e("p",[a._v("当 block 被 copy 到堆上时，会调用block内部的 copy 函数，copy 函数会调用 "),e("code",[a._v("__Block_object_assign")])]),a._v(" "),e("h2",{attrs:{id:"内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),e("h2",{attrs:{id:"runtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[a._v("#")]),a._v(" Runtime")]),a._v(" "),e("h2",{attrs:{id:"runloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[a._v("#")]),a._v(" Runloop")]),a._v(" "),e("p",[a._v("https://blog.csdn.net/u014600626/article/details/50864172")]),a._v(" "),e("h3",{attrs:{id:"面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[a._v("#")]),a._v(" 面试题")]),a._v(" "),e("h4",{attrs:{id:"runloop-内部实现逻辑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop-内部实现逻辑"}},[a._v("#")]),a._v(" Runloop 内部实现逻辑")]),a._v(" "),e("h4",{attrs:{id:"runloop-和线程的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop-和线程的关系"}},[a._v("#")]),a._v(" Runloop 和线程的关系")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("一个运行着的程序就是一个进程或者一个任务。每个进程至少有一个线程，线程就是程序的执行流。创建好一个进程的同时，一个线程便同时开始运行，也就是主线程。每个进程有自己独立的虚拟内存空间，线程之间共用进程的内存空间。有些线程执行的任务是一条直线，起点到终点；在 iOS 中，圆型的线程就是通过run loop不停的循环实现的。\n1.每个线程包括主线程都有与之对应的 runloop 对象，线程和 runloop 对象是一一对应的；\n2.Runloop 保存在一个全局字典中，线程为key, runloop为value CFDictionaryGetValue\n3.主线程会默认开启 runloop , 子线程默认不会开启，需要手动开启\n4.runloop 在第一次获取时创建，在线程结束时销毁\n")])])]),e("h4",{attrs:{id:"timer-和-runloop-的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#timer-和-runloop-的关系"}},[a._v("#")]),a._v(" timer 和 Runloop 的关系")]),a._v(" "),e("h4",{attrs:{id:"runloop-是怎么相应用户操作的-具体操作流程是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop-是怎么相应用户操作的-具体操作流程是什么"}},[a._v("#")]),a._v(" Runloop 是怎么相应用户操作的，具体操作流程是什么")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("首先由Source1捕捉系统事件，然后包装成eventqueue，传递给Source0处理触摸事件\n")])])]),e("h4",{attrs:{id:"runloop的几种状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop的几种状态"}},[a._v("#")]),a._v(" Runloop的几种状态")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Entry\nbeforeTimers\nbeforeSources\nbeforeWaiting\nafterWaiting\nexit\n")])])]),e("h4",{attrs:{id:"runloop-的mode作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop-的mode作用是什么"}},[a._v("#")]),a._v(" Runloop 的mode作用是什么")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("mode作用是用来隔离, 将不同组的Source0、Source1、timer、Observer 隔离开来，互不影响\n主要有 \ndefaultMode : app的默认 mode，通常主线程在这个mode下运行\nUITrackingMode : 界面追踪 mode, 用于scrollview追踪触摸滑动，保证界面滑动时不受其他 Mode 影响\n")])])]),e("h4",{attrs:{id:"runloop-在实际开发中的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop-在实际开发中的作用"}},[a._v("#")]),a._v(" Runloop 在实际开发中的作用")]),a._v(" "),e("p",[a._v("控制线程生命周期（线程保活）")]),a._v(" "),e("p",[a._v("检测应用卡顿")]),a._v(" "),e("p",[a._v("性能优化")]),a._v(" "),e("h4",{attrs:{id:"runloop-休眠的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runloop-休眠的实现原理"}},[a._v("#")]),a._v(" Runloop 休眠的实现原理")]),a._v(" "),e("p",[a._v("用户态和内核态之间的相互切换")]),a._v(" "),e("p",[a._v("mach_msg()")]),a._v(" "),e("p",[a._v("用户态 ----\x3e 内核态 （等待消息）")]),a._v(" "),e("p",[a._v("内核态 ----\x3e用户态 （处理消息）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("内核态：\n等待消息\n没有消息就让线程休眠\n有消息就唤醒线程\n")])])]),e("h3",{attrs:{id:"other"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[a._v("#")]),a._v(" other")]),a._v(" "),e("p",[e("code",[a._v("viewDidLoad")]),a._v("和"),e("code",[a._v("viewWillAppear")]),a._v("在同一个RunLoop循环中")]),a._v(" "),e("p",[a._v("UIApplicationMain 启动了 runloop")]),a._v(" "),e("h2",{attrs:{id:"autoreleasepool"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool"}},[a._v("#")]),a._v(" AutoReleasePool")]),a._v(" "),e("h4",{attrs:{id:"autoreleasepool的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool的实现原理"}},[a._v("#")]),a._v(" AutoreleasePool的实现原理")]),a._v(" "),e("p",[a._v("AutoreleasePool 是 oc 的一种内存回收机制，正常情况下变量在超出作用域的时候 release，但是如果将变量加入到 pool 中，那么release 将延迟执行")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以**双向链表**形式组成\n\n1. PAGE_MAX_SIZE ：4KB，虚拟内存每个扇区的大小，内存对齐\n2. 内部 thread ，page 当前所在的线程，AutoreleasePool是按线程一一对应的\n3. 本身的成员变量占用56字节，剩下的内存存储了调用 autorelease 的变量的对象的地址，同时将一个哨兵插入page中\n4. pool_boundry 哨兵标记，哨兵其实就是一个空地址，用来区分每一个page 的边界\n5. 当一个Page被占满后，会新建一个page，并插入哨兵标记\n")])])]),e("p",[a._v("单个自动释放池的执行过程就是"),e("code",[a._v("objc_autoreleasePoolPush()")]),a._v(" —> "),e("code",[a._v("[object autorelease]")]),a._v(" —> "),e("code",[a._v("objc_autoreleasePoolPop(void *)")])]),a._v(" "),e("p",[a._v("具体实现如下：")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("void *objc_autoreleasePoolPush(void) {\n    return AutoreleasePoolPage::push();\n}\n\nvoid objc_autoreleasePoolPop(void *ctxt) {\n    AutoreleasePoolPage::pop(ctxt);\n}\n")])])]),e("p",[a._v("内部实际上是对 AutoreleasePoolPage 的调用")]),a._v(" "),e("h5",{attrs:{id:"objc-autoreleasepoolpush"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#objc-autoreleasepoolpush"}},[a._v("#")]),a._v(" objc_autoreleasePoolPush")]),a._v(" "),e("p",[a._v("每当自动释放池调用 objc_autoreleasePoolPush 时，都会把边界对象放进栈顶，然后返回边界对象，用于释放。")]),a._v(" "),e("p",[e("code",[a._v("AutoreleasePoolPage::push();")]),a._v("  调用👇")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("static inline void *push() {\n   return autoreleaseFast(POOL_BOUNDARY);\n}\n")])])]),e("p",[e("code",[a._v("autoreleaseFast")]),a._v("👇")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("static inline id *autoreleaseFast(id obj)\n{\n   AutoreleasePoolPage *page = hotPage();\n   if (page && !page->full()) {\n       return page->add(obj);\n   } else if (page) {\n       return autoreleaseFullPage(obj, page);\n   } else {\n       return autoreleaseNoPage(obj);\n   }\n}\n")])])]),e("p",[a._v("👆上述方法分三种情况选择不同的代码执行：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("- 有 hotPage 并且当前 page 不满，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n- 有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n- 无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page->add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中\n\n最后的都会调用 page->add(obj) 将对象添加到自动释放池中。 hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。\n")])])]),e("h4",{attrs:{id:"autoreleasepoolpage"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepoolpage"}},[a._v("#")]),a._v(" AutoreleasePoolPage")]),a._v(" "),e("div",{staticClass:"language-objective-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("是以栈的形式存在，并且内部对象通过进栈、出栈对应着 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop\n  \n当我们对一个对象发送一条 autorelease 消息时，实际上是将这个对象地址加入到 autoreleasePoolPage 的栈顶 next 指针的指向的位置\n")])])]),e("h4",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])]),a._v(" "),e("h2",{attrs:{id:"多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[a._v("#")]),a._v(" 多线程")]),a._v(" "),e("h3",{attrs:{id:"线程与队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程与队列"}},[a._v("#")]),a._v(" 线程与队列")]),a._v(" "),e("p",[a._v("同步、异步 Dispatch_async 和 dispatch_sync 决定了是否开启新的线程")]),a._v(" "),e("p",[a._v("并发、串行 concurrent 、serial 队列的类型决定了任务的执行方式")]),a._v(" "),e("h3",{attrs:{id:"死锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),e("p",[a._v("使用 sync 向"),e("strong",[a._v("当前串行队列")]),a._v("中添加任务，会卡住当前的串行队列（产生死锁）")]),a._v(" "),e("h3",{attrs:{id:"锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[a._v("#")]),a._v(" 锁")]),a._v(" "),e("h4",{attrs:{id:"自旋锁-osspinlock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁-osspinlock"}},[a._v("#")]),a._v(" 自旋锁 OSSpinLock")]),a._v(" "),e("p",[a._v("自旋锁不再安全 等待锁的线程会处于忙等状态，一直占用着CPU的资源")]),a._v(" "),e("p",[a._v("可能会出现优先级反转的问题")]),a._v(" "),e("h2",{attrs:{id:"组件化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[a._v("#")]),a._v(" 组件化")]),a._v(" "),e("h2",{attrs:{id:"设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[a._v("#")]),a._v(" 设计模式")]),a._v(" "),e("h2",{attrs:{id:"插件化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插件化"}},[a._v("#")]),a._v(" 插件化")]),a._v(" "),e("h2",{attrs:{id:"算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[a._v("#")]),a._v(" 算法")]),a._v(" "),e("h2",{attrs:{id:"链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[a._v("#")]),a._v(" 链表")]),a._v(" "),e("h2",{attrs:{id:"二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[a._v("#")]),a._v(" 二叉树")])])}),[],!1,null,null,null);t.default=r.exports}}]);