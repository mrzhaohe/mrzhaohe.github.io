<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>贺先生的博客</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="我的个人网站">
    <link rel="preload" href="/assets/css/0.styles.ccac5a78.css" as="style"><link rel="preload" href="/assets/js/app.8d167866.js" as="script"><link rel="preload" href="/assets/js/2.a077342b.js" as="script"><link rel="preload" href="/assets/js/9.0534ede8.js" as="script"><link rel="prefetch" href="/assets/js/10.9781da34.js"><link rel="prefetch" href="/assets/js/11.32d6265c.js"><link rel="prefetch" href="/assets/js/12.78c2145e.js"><link rel="prefetch" href="/assets/js/3.8099ba9f.js"><link rel="prefetch" href="/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/assets/js/5.15dae563.js"><link rel="prefetch" href="/assets/js/6.bae11fb5.js"><link rel="prefetch" href="/assets/js/7.fdd834b0.js"><link rel="prefetch" href="/assets/js/8.2a42f013.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ccac5a78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">贺先生的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/iOS/" class="nav-link router-link-active">
  iOS
</a></div><div class="nav-item"><a href="/FE/" class="nav-link">
  前端
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="other" class="dropdown-title"><span class="title">other</span> <span class="arrow down"></span></button> <button type="button" aria-label="other" class="mobile-dropdown-title"><span class="title">other</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/PHP/" class="nav-link">
  PHP
</a></li><li class="dropdown-item"><!----> <a href="/other/Flutter/" class="nav-link">
  Flutter
</a></li></ul></div></div> <a href="https://github.com/mrzhaohe/blog-of-zhaohe" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/iOS/" class="nav-link router-link-active">
  iOS
</a></div><div class="nav-item"><a href="/FE/" class="nav-link">
  前端
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="other" class="dropdown-title"><span class="title">other</span> <span class="arrow down"></span></button> <button type="button" aria-label="other" class="mobile-dropdown-title"><span class="title">other</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/PHP/" class="nav-link">
  PHP
</a></li><li class="dropdown-item"><!----> <a href="/other/Flutter/" class="nav-link">
  Flutter
</a></li></ul></div></div> <a href="https://github.com/mrzhaohe/blog-of-zhaohe" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>iOS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS/面试题.html" class="active sidebar-link">/iOS/面试题.html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS/面试题.html#底层原理" class="sidebar-link">底层原理</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#其他原理" class="sidebar-link">其他原理</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#block" class="sidebar-link">Block</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#内存管理" class="sidebar-link">内存管理</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#runtime" class="sidebar-link">Runtime</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#runloop" class="sidebar-link">Runloop</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#autoreleasepool" class="sidebar-link">AutoReleasePool</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#多线程" class="sidebar-link">多线程</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#组件化" class="sidebar-link">组件化</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#设计模式" class="sidebar-link">设计模式</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#插件化" class="sidebar-link">插件化</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#算法" class="sidebar-link">算法</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#链表" class="sidebar-link">链表</a></li><li class="sidebar-sub-header"><a href="/iOS/面试题.html#二叉树" class="sidebar-link">二叉树</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[TOC]</p> <h1 id="interview"><a href="#interview" class="header-anchor">#</a> InterView</h1> <h2 id="底层原理"><a href="#底层原理" class="header-anchor">#</a> 底层原理</h2> <h3 id="oc对象"><a href="#oc对象" class="header-anchor">#</a> OC对象</h3> <p>一个NSObject对象占用多少内存？</p> <div class="language- extra-class"><pre class="language-text"><code>系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）
</code></pre></div><p>对象的isa指针指向哪里？</p> <div class="language- extra-class"><pre class="language-text"><code> instance对象的isa指向class对象 class对象的isa指向meta-class对象 meta-class对象的isa指向基类的meta-class对象
</code></pre></div><p>OC的类信息存放在哪里？</p> <div class="language- extra-class"><pre class="language-text"><code>对象方法、属性、成员变量、协议信息，存放在class对象中 类方法，存放在meta-class对象中 成员变量的具体值，存放在instance对象
</code></pre></div><p>class_rw_t 与 class_ro_t 区别</p> <div class="language- extra-class"><pre class="language-text"><code>class_rw_t结构体内有一个指向class_ro_t结构体的指针.
class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集

当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容
属性(property)存放在class_rw_t中，实例变量(ivar)存放在class_ro_t中。
</code></pre></div><p>msg_send 消息转发</p> <div class="language-objective-c extra-class"><pre class="language-text"><code>分为三个阶段
1、动态方法解析 

  + (BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(run)) {
        return NO;//返回 NO， 才会执行第二步
    }
    return [super resolveInstanceMethod:sel];
	}
	
2、快速转发 
  
  - (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(run)) {
//        return  [Dog new]; //替换其他消息接受者
        return nil; //返回nil 则会走到第3阶段，完全消息转发机制（慢速转发）
    }
    return  [super forwardingTargetForSelector:aSelector];
	}
  
3、完全消息转发
  
  3.1方法签名
  - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(run)) {
        Dog *dog = [Dog new];
        return [dog methodSignatureForSelector:aSelector];
    }
    return [super methodSignatureForSelector:aSelector];
	}
	3.2 消息转发
    - (void)forwardInvocation:(NSInvocation *)anInvocation {
    Dog *dog = [Dog new];
    if ([dog respondsToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:dog];
    } else {
        [super forwardInvocation:anInvocation];
    }
	}
</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn3kd0skfkj30lq0cb3z6.jpg" alt=""></p> <p>iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</p> <div class="language- extra-class"><pre class="language-text"><code>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 willChangeValueForKey: 父类原来的setter didChangeValueForKey: 内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）
</code></pre></div><p>IMP、SEL、Method的区别</p> <div class="language- extra-class"><pre class="language-text"><code>SEL是方法编号，也是方法名
IMP是函数实现指针，找IMP就是找函数实现的过程
Method就是具体的实现
SEL和IMP的关系就可以解释为：
SEL就相当于书本的⽬录标题
IMP就是书本的⻚码
Method就是具体页码对应的内容
SEL是在dyld加载镜像到内存时，通过_read_image方法加载到内存的表中了
</code></pre></div><h2 id="其他原理"><a href="#其他原理" class="header-anchor">#</a> 其他原理</h2> <h4 id="单例"><a href="#单例" class="header-anchor">#</a> 单例</h4> <div class="language- extra-class"><pre class="language-text"><code>使用@synchronized虽然解决了多线程的问题，但是并不完美。因为只有在single未创建时，我们加锁才是有必要的。如果single已经创建.这时候锁不仅没有好处，而且还会影响到程序执行的性能（多个线程执行@synchronized中的代码时，只有一个线程执行，其他线程需要等待）。

当onceToken= 0时，线程执行dispatch_once的block中代码 当onceToken= -1时，线程跳过dispatch_once的block中代码不执行 当onceToken为其他值时，线程被阻塞，等待onceToken值改变
</code></pre></div><h4 id="通知"><a href="#通知" class="header-anchor">#</a> 通知</h4> <p><a href="https://www.jianshu.com/p/4a44b9a15fe9?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener noreferrer">通知实现原理参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language- extra-class"><pre class="language-text"><code>两张表 Named Table NotificationName作为表的key， nameless table 没有传入NotificationName wildcard
</code></pre></div><h4 id="copy"><a href="#copy" class="header-anchor">#</a> copy</h4> <h5 id="copy-与-strong"><a href="#copy-与-strong" class="header-anchor">#</a> <strong>copy 与 strong</strong></h5> <p>使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</p> <p>如果我们使用 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p> <div class="language-objective-c extra-class"><pre class="language-text"><code>		NSMutableString *string = [[NSMutableString alloc] initWithString:@&quot;0&quot;];
    
    NSString *copyString = [string mutableCopy];
    NSString *strongString = string;
    
    [string appendString:@&quot;1&quot;];
    
    NSLog(@&quot;copyString = %@&quot;, copyString);
    NSLog(@&quot;strongString = %@&quot;, strongString);
</code></pre></div><h5 id="copy-与-mutablecopy"><a href="#copy-与-mutablecopy" class="header-anchor">#</a> copy 与 mutableCopy</h5> <p>不可变对象 copy 指针拷贝  浅拷贝 仅此一种情况</p> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">copy</th> <th style="text-align:center;">mutableCopy</th></tr></thead> <tbody><tr><td style="text-align:center;">不可变对象</td> <td style="text-align:center;">浅拷贝 （指针拷贝）</td> <td style="text-align:center;">深拷贝</td></tr> <tr><td style="text-align:center;">可变对象</td> <td style="text-align:center;">深拷贝</td> <td style="text-align:center;">深拷贝</td></tr></tbody></table> <h3 id="weak的实现原理-sidetable的内部结构"><a href="#weak的实现原理-sidetable的内部结构" class="header-anchor">#</a> weak的实现原理，sideTable的内部结构</h3> <p>weak表其实是一个hash表，key 是所指对象的地址，value 是 weak 指针的地址数组，</p> <p>sideTable是一个结构体，内部主要有引用计数表和弱引用表两个成员，内存存储的其实都是对象的地址、引用计数和weak变量的地址，而不是对象本身的数据</p> <h2 id="block"><a href="#block" class="header-anchor">#</a> Block</h2> <p>block的原理是什么 本质是什么</p> <div class="language- extra-class"><pre class="language-text"><code>本质是一个 oc 对象， 内部也有一个 isa 指针
内部封装了 block 执行逻辑的函数
</code></pre></div><h3 id="block-的本质"><a href="#block-的本质" class="header-anchor">#</a> Block 的本质</h3> <p><strong>结构体对象</strong></p> <div class="language-objective-c extra-class"><pre class="language-text"><code>int age = 20;
void (^block) (void) = ^ {
	NSLog(@&quot;age is %d&quot;, age);
};
</code></pre></div><p>变量自动捕获👇</p> <div class="language-c++ extra-class"><pre class="language-text"><code>struct __main_block_impl_0 {
	struct __block_impl impl; //impl 结构体见👇
	struct __main_block_desc_0* Desc;
	int age;// 自动变量捕获
}
</code></pre></div><div class="language-c++ extra-class"><pre class="language-text"><code>struct __block_impl {
	void *isa;
	int Flags;
	int Reserved;
	void *FuncPtr; //指向 block 内部实现的函数地址 (见👇)
}
</code></pre></div><div class="language-c++ extra-class"><pre class="language-text"><code>// 封装了 block 执行逻辑的函数
static void __main_block_func_0 () {
	//TODO
}
</code></pre></div><h3 id="变量捕获"><a href="#变量捕获" class="header-anchor">#</a> 变量捕获</h3> <p>auto 值传递</p> <p>static 指针传递</p> <p>全局变量 不捕获 直接访问</p> <p>局部变量需要捕获是因为需要<code>跨函数</code>访问</p> <h3 id="block-类型"><a href="#block-类型" class="header-anchor">#</a> Block 类型</h3> <p><code>继承自NSBlock类型</code></p> <div class="language- extra-class"><pre class="language-text"><code>globleBlock 没有访问 auto 变量 （访问 static 和 全局变量仍让是 globelBlock）

​ stackBlock 访问了 auto 变量 (MRC 下能打印出来, ARC下会自动调动 copy ---&gt; mallocBlock)

​ mallocBlock ----&gt; stackBlock 调用了 copy （栈 --- &gt; 堆上）  
</code></pre></div><h3 id="block的作用"><a href="#block的作用" class="header-anchor">#</a> __block的作用</h3> <div class="language- extra-class"><pre class="language-text"><code>__block 可解决 block 内部无法修改 auto 变量的问题 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>编译器会将__block变量包装成一个对象 __Block_byref_xxx_0
</code></pre></div><p>基本数据类型 <code>int age = 0;</code> 编译器会将 age 包装成 <code>__Block_byref_age_0</code> 结构体</p> <p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gng930adqfj30ec06c0tl.jpg" alt=""></p> <div class="language- extra-class"><pre class="language-text"><code>1.__main_block_impl_0 结构体内持有  __Block_byref_age_0
2.__Block_byref_age_0 内部持有 __forwarding 指针指向自己
</code></pre></div><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gng939naeuj30mk07676r.jpg" style="zoom:67%;"> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gng92mq03kj30li09smyv.jpg" style="zoom:67%;"> <h3 id="block-内存管理"><a href="#block-内存管理" class="header-anchor">#</a> Block 内存管理</h3> <p>当 block 被 copy 到堆上时，会调用block内部的 copy 函数，copy 函数会调用 <code>__Block_object_assign</code></p> <h2 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h2> <h2 id="runtime"><a href="#runtime" class="header-anchor">#</a> Runtime</h2> <h2 id="runloop"><a href="#runloop" class="header-anchor">#</a> Runloop</h2> <p>https://blog.csdn.net/u014600626/article/details/50864172</p> <h3 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h3> <h4 id="runloop-内部实现逻辑"><a href="#runloop-内部实现逻辑" class="header-anchor">#</a> Runloop 内部实现逻辑</h4> <h4 id="runloop-和线程的关系"><a href="#runloop-和线程的关系" class="header-anchor">#</a> Runloop 和线程的关系</h4> <div class="language- extra-class"><pre class="language-text"><code>一个运行着的程序就是一个进程或者一个任务。每个进程至少有一个线程，线程就是程序的执行流。创建好一个进程的同时，一个线程便同时开始运行，也就是主线程。每个进程有自己独立的虚拟内存空间，线程之间共用进程的内存空间。有些线程执行的任务是一条直线，起点到终点；在 iOS 中，圆型的线程就是通过run loop不停的循环实现的。
1.每个线程包括主线程都有与之对应的 runloop 对象，线程和 runloop 对象是一一对应的；
2.Runloop 保存在一个全局字典中，线程为key, runloop为value CFDictionaryGetValue
3.主线程会默认开启 runloop , 子线程默认不会开启，需要手动开启
4.runloop 在第一次获取时创建，在线程结束时销毁
</code></pre></div><h4 id="timer-和-runloop-的关系"><a href="#timer-和-runloop-的关系" class="header-anchor">#</a> timer 和 Runloop 的关系</h4> <h4 id="runloop-是怎么相应用户操作的-具体操作流程是什么"><a href="#runloop-是怎么相应用户操作的-具体操作流程是什么" class="header-anchor">#</a> Runloop 是怎么相应用户操作的，具体操作流程是什么</h4> <div class="language- extra-class"><pre class="language-text"><code>首先由Source1捕捉系统事件，然后包装成eventqueue，传递给Source0处理触摸事件
</code></pre></div><h4 id="runloop的几种状态"><a href="#runloop的几种状态" class="header-anchor">#</a> Runloop的几种状态</h4> <div class="language- extra-class"><pre class="language-text"><code>Entry
beforeTimers
beforeSources
beforeWaiting
afterWaiting
exit
</code></pre></div><h4 id="runloop-的mode作用是什么"><a href="#runloop-的mode作用是什么" class="header-anchor">#</a> Runloop 的mode作用是什么</h4> <div class="language- extra-class"><pre class="language-text"><code>mode作用是用来隔离, 将不同组的Source0、Source1、timer、Observer 隔离开来，互不影响
主要有 
defaultMode : app的默认 mode，通常主线程在这个mode下运行
UITrackingMode : 界面追踪 mode, 用于scrollview追踪触摸滑动，保证界面滑动时不受其他 Mode 影响
</code></pre></div><h4 id="runloop-在实际开发中的作用"><a href="#runloop-在实际开发中的作用" class="header-anchor">#</a> Runloop 在实际开发中的作用</h4> <p>控制线程生命周期（线程保活）</p> <p>检测应用卡顿</p> <p>性能优化</p> <h4 id="runloop-休眠的实现原理"><a href="#runloop-休眠的实现原理" class="header-anchor">#</a> Runloop 休眠的实现原理</h4> <p>用户态和内核态之间的相互切换</p> <p>mach_msg()</p> <p>用户态 ----&gt; 内核态 （等待消息）</p> <p>内核态 ----&gt;用户态 （处理消息）</p> <div class="language- extra-class"><pre class="language-text"><code>内核态：
等待消息
没有消息就让线程休眠
有消息就唤醒线程
</code></pre></div><h3 id="other"><a href="#other" class="header-anchor">#</a> other</h3> <p><code>viewDidLoad</code>和<code>viewWillAppear</code>在同一个RunLoop循环中</p> <p>UIApplicationMain 启动了 runloop</p> <h2 id="autoreleasepool"><a href="#autoreleasepool" class="header-anchor">#</a> AutoReleasePool</h2> <h4 id="autoreleasepool的实现原理"><a href="#autoreleasepool的实现原理" class="header-anchor">#</a> AutoreleasePool的实现原理</h4> <p>AutoreleasePool 是 oc 的一种内存回收机制，正常情况下变量在超出作用域的时候 release，但是如果将变量加入到 pool 中，那么release 将延迟执行</p> <div class="language- extra-class"><pre class="language-text"><code>AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以**双向链表**形式组成

1. PAGE_MAX_SIZE ：4KB，虚拟内存每个扇区的大小，内存对齐
2. 内部 thread ，page 当前所在的线程，AutoreleasePool是按线程一一对应的
3. 本身的成员变量占用56字节，剩下的内存存储了调用 autorelease 的变量的对象的地址，同时将一个哨兵插入page中
4. pool_boundry 哨兵标记，哨兵其实就是一个空地址，用来区分每一个page 的边界
5. 当一个Page被占满后，会新建一个page，并插入哨兵标记
</code></pre></div><p>单个自动释放池的执行过程就是<code>objc_autoreleasePoolPush()</code> —&gt; <code>[object autorelease]</code> —&gt; <code>objc_autoreleasePoolPop(void *)</code></p> <p>具体实现如下：</p> <div class="language-c++ extra-class"><pre class="language-text"><code>void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre></div><p>内部实际上是对 AutoreleasePoolPage 的调用</p> <h5 id="objc-autoreleasepoolpush"><a href="#objc-autoreleasepoolpush" class="header-anchor">#</a> objc_autoreleasePoolPush</h5> <p>每当自动释放池调用 objc_autoreleasePoolPush 时，都会把边界对象放进栈顶，然后返回边界对象，用于释放。</p> <p><code>AutoreleasePoolPage::push();</code>  调用👇</p> <div class="language-c++ extra-class"><pre class="language-text"><code>static inline void *push() {
   return autoreleaseFast(POOL_BOUNDARY);
}
</code></pre></div><p><code>autoreleaseFast</code>👇</p> <div class="language-c++ extra-class"><pre class="language-text"><code>static inline id *autoreleaseFast(id obj)
{
   AutoreleasePoolPage *page = hotPage();
   if (page &amp;&amp; !page-&gt;full()) {
       return page-&gt;add(obj);
   } else if (page) {
       return autoreleaseFullPage(obj, page);
   } else {
       return autoreleaseNoPage(obj);
   }
}
</code></pre></div><p>👆上述方法分三种情况选择不同的代码执行：</p> <div class="language- extra-class"><pre class="language-text"><code>- 有 hotPage 并且当前 page 不满，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中
- 有 hotPage 并且当前 page 已满，调用 autoreleaseFullPage 初始化一个新的页，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中
- 无 hotPage，调用 autoreleaseNoPage 创建一个 hotPage，调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中

最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。 hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。
</code></pre></div><h4 id="autoreleasepoolpage"><a href="#autoreleasepoolpage" class="header-anchor">#</a> AutoreleasePoolPage</h4> <div class="language-objective-c extra-class"><pre class="language-text"><code>是以栈的形式存在，并且内部对象通过进栈、出栈对应着 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop
  
当我们对一个对象发送一条 autorelease 消息时，实际上是将这个对象地址加入到 autoreleasePoolPage 的栈顶 next 指针的指向的位置
</code></pre></div><h4 id=""><a href="#" class="header-anchor">#</a></h4> <h2 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h2> <h3 id="线程与队列"><a href="#线程与队列" class="header-anchor">#</a> 线程与队列</h3> <p>同步、异步 Dispatch_async 和 dispatch_sync 决定了是否开启新的线程</p> <p>并发、串行 concurrent 、serial 队列的类型决定了任务的执行方式</p> <h3 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h3> <p>使用 sync 向<strong>当前串行队列</strong>中添加任务，会卡住当前的串行队列（产生死锁）</p> <h3 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h3> <h4 id="自旋锁-osspinlock"><a href="#自旋锁-osspinlock" class="header-anchor">#</a> 自旋锁 OSSpinLock</h4> <p>自旋锁不再安全 等待锁的线程会处于忙等状态，一直占用着CPU的资源</p> <p>可能会出现优先级反转的问题</p> <h2 id="组件化"><a href="#组件化" class="header-anchor">#</a> 组件化</h2> <h2 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h2> <h2 id="插件化"><a href="#插件化" class="header-anchor">#</a> 插件化</h2> <h2 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h2> <h2 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h2> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8d167866.js" defer></script><script src="/assets/js/2.a077342b.js" defer></script><script src="/assets/js/9.0534ede8.js" defer></script>
  </body>
</html>
